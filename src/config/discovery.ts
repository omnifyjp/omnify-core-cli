/**
 * Package Auto-Discovery Module
 *
 * Reads `.omnify-packages.json` manifest generated by Composer plugin
 * and merges discovered packages with explicit additionalSchemaPaths.
 */

import { existsSync, readFileSync } from 'node:fs';
import { resolve, dirname } from 'node:path';
import type {
  OmnifyPackagesManifest,
  OmnifyPackageConfig,
  AdditionalSchemaPath,
  DiscoveryConfig,
} from './types.js';
import { logger } from '../output/logger.js';

/** Default manifest filename */
const MANIFEST_FILENAME = '.omnify-packages.json';

/** Current manifest version */
const MANIFEST_VERSION = 1;

/**
 * Load package manifest from project root.
 *
 * @param projectRoot - Project root directory
 * @returns Parsed manifest or null if not found
 */
export function loadPackageManifest(projectRoot: string): OmnifyPackagesManifest | null {
  const manifestPath = resolve(projectRoot, MANIFEST_FILENAME);

  if (!existsSync(manifestPath)) {
    logger.debug(`Package manifest not found: ${manifestPath}`);
    return null;
  }

  try {
    const content = readFileSync(manifestPath, 'utf-8');
    const manifest = JSON.parse(content) as OmnifyPackagesManifest;

    // Validate version
    if (manifest.version !== MANIFEST_VERSION) {
      logger.warn(
        `Package manifest version mismatch: expected ${MANIFEST_VERSION}, got ${manifest.version}. ` +
        'Run `composer dump-autoload` to regenerate.'
      );
    }

    return manifest;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logger.warn(`Failed to read package manifest: ${message}`);
    return null;
  }
}

/**
 * Convert package config from manifest to AdditionalSchemaPath.
 *
 * @param packageName - Package name (e.g., 'vendor/package')
 * @param config - Package configuration from manifest
 * @returns AdditionalSchemaPath entry
 */
function packageConfigToSchemaPath(
  packageName: string,
  config: OmnifyPackageConfig
): AdditionalSchemaPath {
  const result: AdditionalSchemaPath = {
    path: config.schemas,
    namespace: config.namespace,
  };

  // Convert package options to output config
  if (config.options) {
    const opts = config.options;
    const basePath = config.schemas.replace(/\/database\/schemas\/?$/, '');

    const laravelOutput: Record<string, unknown> = {
      base: basePath,
    };

    if (opts.modelNamespace) {
      laravelOutput.modelsNamespace = opts.modelNamespace;
    }
    if (opts.migrationsPath) {
      laravelOutput.migrationsPath = opts.migrationsPath.replace(basePath + '/', '');
    }
    if (opts.factoriesPath) {
      laravelOutput.factoriesPath = opts.factoriesPath.replace(basePath + '/', '');
    }
    if (opts.generateServiceProvider !== undefined) {
      laravelOutput.generateServiceProvider = opts.generateServiceProvider;
    }
    if (opts.generateMigrations !== undefined) {
      laravelOutput.generateMigrations = opts.generateMigrations;
    }
    if (opts.generateModels !== undefined) {
      laravelOutput.generateModels = opts.generateModels;
    }

    (result as { output?: unknown }).output = { laravel: laravelOutput };
  }

  return result;
}

/**
 * Discover packages from manifest and merge with explicit paths.
 *
 * @param projectRoot - Project root directory
 * @param discoveryConfig - Discovery configuration
 * @param explicitPaths - Explicit additionalSchemaPaths from config
 * @returns Merged array of schema paths (discovered + explicit)
 */
export function discoverPackages(
  projectRoot: string,
  discoveryConfig: DiscoveryConfig,
  explicitPaths?: readonly AdditionalSchemaPath[]
): AdditionalSchemaPath[] {
  const result: AdditionalSchemaPath[] = [];
  const excludeSet = new Set(discoveryConfig.exclude ?? []);

  // Load auto-discovered packages
  if (discoveryConfig.enabled !== false) {
    const manifest = loadPackageManifest(projectRoot);

    if (manifest) {
      // Sort by priority (lower = first)
      const sortedPackages = Object.entries(manifest.packages).sort(
        ([, a], [, b]) => (a.priority ?? 100) - (b.priority ?? 100)
      );

      for (const [packageName, config] of sortedPackages) {
        // Skip excluded packages
        if (excludeSet.has(packageName)) {
          logger.debug(`Skipping excluded package: ${packageName}`);
          continue;
        }

        // Skip if schema path doesn't exist
        const schemasPath = resolve(projectRoot, config.schemas);
        if (!existsSync(schemasPath)) {
          logger.debug(`Package schemas not found, skipping: ${schemasPath}`);
          continue;
        }

        result.push(packageConfigToSchemaPath(packageName, config));
        logger.debug(`Discovered package: ${packageName} (${config.namespace ?? 'no namespace'})`);
      }

      if (result.length > 0) {
        logger.info(`Auto-discovered ${result.length} package(s) from ${MANIFEST_FILENAME}`);
      }
    }
  }

  // Append explicit paths (they take precedence / can override)
  if (explicitPaths?.length) {
    result.push(...explicitPaths);
  }

  return result;
}

/**
 * Get the manifest file path for a project.
 */
export function getManifestPath(projectRoot: string): string {
  return resolve(projectRoot, MANIFEST_FILENAME);
}
